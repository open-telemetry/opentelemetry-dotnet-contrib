// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

namespace Microsoft.LinuxTracepoints.Provider;

using System;
using Debug = System.Diagnostics.Debug;
using EventLevel = System.Diagnostics.Tracing.EventLevel;

/// <summary>
/// Represents a tracepoint registered for a specific provider + level + keyword.
/// The tracepoint name is based on provider name + level + keyword + provider group,
/// e.g. "MyProviderName_L1K1" or "MyProviderName_L1K1Ggroup".
/// <br/>
/// Tracepoint operations are thread safe.
/// If tracepoint registration fails or if the tracepoint is unregistered, IsEnabled
/// will return false and Writing to the tracepoint will be a safe no-op (immediately
/// returns EBADF).
/// <br/>
/// Tracepoint operations:
/// <list type="bullet"><item>
/// Register: Create tracepoints using <see cref="EventHeaderDynamicProvider"/>.Register.
/// </item><item>
/// Unregister: Close tracepoints using <see cref="EventHeaderDynamicProvider"/>.Dispose.
/// </item><item>
/// Write: Generate an event using <see cref="EventHeaderDynamicBuilder"/>.Write.
/// </item><item>
/// Enabled: Determine whether any trace collection session is listening for this tracepoint
/// by checking the IsEnabled property. This is optional (calling Write with a disabled
/// or unregistered tracepoint is a safe no-op) but can help improve performance (avoids the
/// overhead of preparing the data for the event).
/// </item><item>
/// Debugging: Determine whether tracepoint registration succeeded by checking the
/// RegisterResult property.
/// </item></list>
/// </summary>
public sealed class EventHeaderDynamicTracepoint : IDisposable
{
    private readonly TracepointHandle handle;

    /// <summary>
    /// As a performance optimization, avoid one level of indirection during calls to IsEnabled
    /// by caching the enablement array. The array always has Length == 1. The contents of this
    /// array should be considered read-only and MUST NOT be modified (the array data is updated
    /// by the Linux kernel when the tracepoint is enabled or disabled).
    /// <br/>
    /// When handle.IsInvalid, one array is shared by all invalid handles and is a normal allocation.
    /// When !handle.IsInvalid, the array is unique for for each handle and is a pinned allocation.
    /// </summary>
    private readonly Int32[] enablementArray;

    internal EventHeaderDynamicTracepoint(
        EventHeaderDynamicProvider provider,
        byte levelByte,
        UInt64 keyword,
        PerfUserEventReg flags)
    {
        var EventHeaderCommandTypes = " u8 eventheader_flags; u8 version; u16 id; u16 tag; u8 opcode; u8 level\0"u8;

        var name = $"{provider.Name}_L{levelByte:x}K{keyword:x}{provider.Options}";

        // command = ProviderName_LnnKnn + EventHeaderCommandTypes

        var command = (stackalloc byte[name.Length + EventHeaderCommandTypes.Length]);
        var commandPos = 0;
        foreach (var ch in name)
        {
            command[commandPos++] = (byte)ch;
        }

        foreach (var ch in EventHeaderCommandTypes)
        {
            command[commandPos++] = ch;
        }

        Debug.Assert(command[commandPos - 1] == 0);
        Debug.Assert(commandPos == command.Length);

        this.handle = TracepointHandle.Register(command, flags);
        this.enablementArray = this.handle.DangerousGetEnablementArray();
        this.Name = name;
        this.LevelByte = levelByte;
        this.Keyword = keyword;
    }

    /// <summary>
    /// Returns a string with the tracepoint name, e.g. "MyProviderName_L5K1f" or
    /// "MyProviderName_L4K1Gmyprovidergroup".
    /// </summary>
    public string Name { get; }

    /// <summary>
    /// EventLevel raw value. (Stores the value of the Level property.)
    /// </summary>
    public Byte LevelByte { get; }

    /// <summary>
    /// Returns the keyword (category bits) of the events generated by this tracepoint.
    /// </summary>
    public UInt64 Keyword { get; }

    /// <summary>
    /// EventLevel: critical, error, warning, info, verbose.
    /// </summary>
    public EventLevel Level => (EventLevel)this.LevelByte;

    /// <summary>
    /// Returns true if this tracepoint is registered and one or more tracepoint collection sessions
    /// are collecting this tracepoint.
    /// <br/>
    /// Returns false if this tracepoint is unregistered or if there are no tracepoint collection
    /// sessions that are collecting this tracepoint. The tracepoint will be unregistered if
    /// registration failed or if the tracepoint has been disposed.
    /// <br/>
    /// Note that this property is provided to support performance optimization, but use of this
    /// property is optional. It's ok to Write to a tracepoint even if IsEnabled returns false. If your
    /// tracepoint is not being collected, the builder.Write method will do nothing and will immediately
    /// return EBADF. The IsEnabled property is provided so that you can efficiently skip preparing your
    /// data and calling builder.Write if your tracepoint is not being collected.
    /// </summary>
    public bool IsEnabled => this.enablementArray[0] != 0;

    /// <summary>
    /// If tracepoint registration succeeded, returns 0.
    /// Otherwise, returns an errno indicating the error.
    /// <br/>
    /// This property is for diagnostic purposes and should usually be ignored for normal
    /// operation -- most programs should continue to operate even if trace registration
    /// fails.
    /// </summary>
    public int RegisterResult => this.handle.RegisterResult;

    /// <summary>
    /// Gets a string identifying this tracepoint.
    /// </summary>
    public override string ToString()
    {
        return this.Name;
    }

    /// <summary>
    /// Unregisters this tracepoint.
    /// </summary>
    void IDisposable.Dispose()
    {
        this.handle.Dispose();
    }

    internal unsafe int WriteRaw(
        EventHeaderDynamicBuilder builder,
        in Guid* activityId,
        in Guid* relatedId)
    {
        if (builder.TooBig)
        {
            return TracepointHandle.EventTooBigError;
        }

        if (this.enablementArray[0] == 0)
        {
            return TracepointHandle.DisabledEventError;
        }

        var meta = builder.GetRawMeta();
        var data = builder.GetRawData();
        unsafe
        {
            fixed (byte* metaPtr = meta, dataPtr = data)
            {
                return this.handle.WriteEventHeader(
                    new EventHeader
                    {
                        Flags = EventHeader.DefaultFlags | EventHeaderFlags.Extension,
                        Version = builder.Version,
                        Id = builder.Id,
                        Tag = builder.Tag,
                        OpcodeByte = builder.OpcodeByte,
                        LevelByte = this.LevelByte,
                    },
                    activityId,
                    relatedId,
                    (ushort)meta.Length,
                    stackalloc DataSegment[] {
                        default, // segment[0] is used for headers.
                        new DataSegment(metaPtr, (uint)meta.Length),
                        new DataSegment(dataPtr, (uint)data.Length),
                    });
            }
        }
    }
}
