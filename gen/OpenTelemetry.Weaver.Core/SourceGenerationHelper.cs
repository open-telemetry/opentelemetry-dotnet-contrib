// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

using System.IO;
using System.Text;

namespace OpenTelemetry.Weaver;

internal static class SourceGenerationHelper
{
    internal static string GenerateNamespaceAttributeNames(Properties generationProperties, StreamReader streamReader)
        => GenerateOtel(GenerationMode.AttributeNames, generationProperties, streamReader);

    internal static string GenerateNamespaceAttributeValues(Properties generationProperties, StreamReader streamReader)
        => GenerateOtel(GenerationMode.AttributeValues, generationProperties, streamReader);

    internal static string GenerateOtel(GenerationMode generationMode, Properties generationProperties, StreamReader streamReader)
    {
        streamReader.ReadLine();
        streamReader.ReadLine();
        streamReader.ReadLine();
        var sb = new StringBuilder();
        sb.AppendLine(@$"
// <auto-generated>
namespace {generationProperties.FileNamespace};

#pragma warning disable CS0618
#pragma warning disable CS8981
internal partial struct {generationProperties.StructName}
{{");

        bool hasExtensions = false;
        var extb = new StringBuilder();
        extb.AppendLine(@$"
internal static partial class {generationProperties.StructName}Extensions
{{");

        string openNamespace = string.Empty;
        string openObject = string.Empty;
        var properties = streamReader.ReadLine()?.Trim('|').Split('|');
        while (properties != null)
        {
            // process each namespace path segment
            var activeNamespace = properties[0].Trim();
            var segments = activeNamespace.Split('.');
            string prefix;
            string name;
            if (openNamespace != activeNamespace)
            {
                for (int i = 0; i < segments.Length - 1; i++)
                {
                    name = segments[i].Trim();
                    prefix = name.Equals("namespace") ? "@" : string.Empty;

                    // create a struct for the namespace
                    if (openNamespace != activeNamespace)
                    {
                        sb.AppendLine(@$"    internal partial struct {prefix}{name.Trim()}
    {{");
                    }
                }
            }

            name = segments[segments.Length - 1].Trim();
            switch (generationMode)
            {
                case GenerationMode.AttributeNames:
                    sb.AppendAttributeName(properties, name);
                    break;
                case GenerationMode.AttributeValues:
                    var targetName = $"{generationProperties.StructName}.{activeNamespace.Trim()}s";
                    if (openNamespace != activeNamespace)
                    {
                        openNamespace = properties[0].Trim();
                        openObject = name + "s";
                        hasExtensions = true;
                        sb.AppendAttributeValueType(properties, openObject);
                        extb.AppendExtensionSwitchOpener(targetName, openObject);
                    }

                    sb.AppendAttributeValue(properties);
                    extb.AppendExtensionSwitchOption(properties, targetName);
                    break;
                default:
                    break;
            }

            properties = streamReader.ReadLine()?.Trim('|').Split('|');

            // Close previous object if open when new namespace or final
            if (properties == null || openNamespace != properties[0].Trim())
            {
                for (int i = 1; i < segments.Length - 1; i++)
                {
                    sb.AppendLine(@"    }");
                }

                if (properties != null || !string.IsNullOrEmpty(openObject))
                {
                    sb.AppendLine(@"    }");
                }

                if (hasExtensions && !string.IsNullOrEmpty(openObject))
                {
                    extb.AppendExtensionSwitchCloser(openObject);
                }

                openNamespace = string.Empty;
                openObject = string.Empty;
            }
        }

        sb.AppendLine("    }")
            .AppendLine("}");
        if (hasExtensions)
        {
            sb.Append(extb)
                .AppendLine("}");
        }

        sb.AppendLine(@"#pragma warning restore CS8981
#pragma warning restore CS0618");
        return sb.ToString();
    }
}
