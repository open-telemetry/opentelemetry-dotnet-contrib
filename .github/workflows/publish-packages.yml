name: Build, pack, and publish

on:
  workflow_dispatch:
  push:
    tags:
      - 'Exporter.*-*'
      - 'Extensions.*-*'
      - 'Extensions-*'
      - 'Instrumentation.*-*'
      - 'PersistentStorage-*'
      - 'Resources.*-*'
      - 'Sampler.*-*'
      - 'SemanticConventions-*'
  schedule:
    - cron: '0 0 * * *' # once in a day at 00:00

permissions:
  contents: read

jobs:
  automation:
    uses: ./.github/workflows/automation.yml
    secrets: inherit

  build-pack-publish:

    runs-on: windows-latest

    outputs:
      artifact-url: ${{ steps.upload-artifacts.outputs.artifact-url }}
      artifact-id: ${{ steps.upload-artifacts.outputs.artifact-id }}

    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          # Note: By default GitHub only fetches 1 commit. MinVer needs to find
          # the version tag which is typically NOT on the first commit so we
          # retrieve them all.
          fetch-depth: 0

      - name: Resolve project
        id: resolve-project
        shell: pwsh
        env:
          TAG: ${{ github.ref_type == 'tag' && github.ref_name || '' }}
        run: |
          Import-Module .\build\scripts\build.psm1

          # Note: The ResolveProjectForTag call here figures out the .proj file to
          # use for the build. It will be either opentelemetry-dotnet-contrib.proj
          # (for manual/scheduled builds), a .proj file in .\build\Projects\ (if
          # one is defined with MinVerTagPrefix matching the tag), or
          # Component.proj for simple projects (where a single csproj has
          # MinVerTagPrefix matching the tag).

          $title = '' # Used for friendly names in action UI
          $project = '' # Actual project passed to dotnet
          $component = '' # Used to tell Component.proj what to build

          ResolveProjectForTag `
            -tag ${env:TAG} `
            -title ([ref]$title) `
            -project ([ref]$project) `
            -component ([ref]$component)

          echo "title=$title" >> ${env:GITHUB_OUTPUT}
          echo "PROJECT_PATH=$project" >> ${env:GITHUB_ENV}

          # Note: BUILD_COMPONENT envvar tells Component.proj what to build. Only
          # used if $project ends up Component.proj.
          echo "BUILD_COMPONENT=$component" >> ${env:GITHUB_ENV}

      - name: Setup dotnet
        uses: actions/setup-dotnet@d4c94342e560b34958eacfc5d055d21461ed1c5d # v5.0.0

      - name: dotnet restore ${{ steps.resolve-project.outputs.title }}
        run: dotnet restore ${env:PROJECT_PATH}

      - name: dotnet build ${{ steps.resolve-project.outputs.title }}
        run: dotnet build ${env:PROJECT_PATH} --configuration Release --no-restore -p:Deterministic=true -p:"BuildNumber=${env:GITHUB_RUN_NUMBER}"

      - name: dotnet test ${{ steps.resolve-project.outputs.title }}
        run: dotnet test ${env:PROJECT_PATH} --configuration Release --no-restore --no-build

      - name: dotnet pack ${{ steps.resolve-project.outputs.title }}
        shell: pwsh
        run: dotnet pack ${env:PROJECT_PATH} --configuration Release --no-restore --no-build  -p:"PackTag=${env:TAG}"

      - name: Publish Artifacts
        id: upload-artifacts
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: ${{ github.ref_name }}-packages
          path: ./artifacts/package/release
          if-no-files-found: error

      - name: Publish to MyGet
        working-directory: ./artifacts/package/release
        env:
          MYGET_TOKEN_EXISTS: ${{ secrets.MYGET_TOKEN != '' }}
          API_KEY: ${{ secrets.MYGET_TOKEN }}
          SOURCE: https://www.myget.org/F/opentelemetry/api/v2/package
        if: env.MYGET_TOKEN_EXISTS == 'true' # Skip MyGet publish if run on a fork without the secret
        shell: pwsh
        run: dotnet nuget push *.nupkg --api-key ${env:API_KEY} --skip-duplicate --source ${env:SOURCE}

      - name: Publish to NuGet
        working-directory: ./artifacts/package/release
        env:
          NUGET_TOKEN_EXISTS: ${{ secrets.NUGET_TOKEN != '' }}
          API_KEY: ${{ secrets.NUGET_TOKEN }}
          SOURCE: https://api.nuget.org/v3/index.json
        if: github.ref_type == 'tag' && env.NUGET_TOKEN_EXISTS == 'true' # Skip NuGet publish for scheduled nightly builds or if run on a fork without the secret
        shell: pwsh
        run: dotnet nuget push *.nupkg --api-key ${env:API_KEY} --skip-duplicate --source ${env:SOURCE}

  post-build:
    runs-on: ubuntu-22.04

    needs:
      - automation
      - build-pack-publish

    if: needs.automation.outputs.enabled && github.event_name == 'push'

    env:
      GH_TOKEN: ${{ secrets[needs.automation.outputs.token-secret-name] }}

    steps:
      - name: Check out code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          token: ${{ env.GH_TOKEN }}

      - name: Download Artifacts
        env:
          ARTIFACT_ID: ${{ needs.build-pack-publish.outputs.artifact-id }}
          ARTIFACT_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          curl \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: token ${ARTIFACT_TOKEN}" \
            -L \
            -o "${GITHUB_WORKSPACE}/artifacts/${GITHUB_REF_NAME}-packages.zip" \
            --create-dirs \
            "${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/actions/artifacts/${ARTIFACT_ID}/zip"

      - name: Create GitHub Release
        if: github.ref_type == 'tag'
        shell: pwsh
        run: |
          Import-Module .\build\scripts\post-release.psm1

          CreateRelease `
            -gitRepository ${env:GITHUB_REPOSITORY} `
            -tag ${env:GITHUB_REF_NAME} `
            -releaseFiles "${env:GITHUB_WORKSPACE}/artifacts/${env:GITHUB_REF_NAME}-packages.zip"

      - name: Post notice when packages are ready
        shell: pwsh
        env:
          BOT_USER_NAME: ${{ needs.automation.outputs.username }}
          PACKAGES_URL: ${{ needs.build-pack-publish.outputs.artifact-url }}
        run: |
          Import-Module .\build\scripts\post-release.psm1

          TryPostPackagesReadyNoticeOnPrepareReleasePullRequest `
            -gitRepository ${env:GITHUB_REPOSITORY} `
            -tag ${env:GITHUB_REF_NAME} `
            -tagSha ${env:GITHUB_SHA} `
            -packagesUrl ${env:PACKAGES_URL} `
            -botUserName ${env:BOT_USER_NAME}
